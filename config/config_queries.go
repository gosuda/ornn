package config

import (
	"fmt"
	"strings"

	"ariga.io/atlas/sql/schema"
	"github.com/gosuda/ornn/atlas"
)

type Queries struct {
	schema *Schema             `json:"-"`
	Class  map[string][]*Query `json:"class"` // auto generated by schema
}

func (t *Queries) init(schema *Schema) {
	t.schema = schema
	if t.Class == nil {
		t.Class = make(map[string][]*Query)
		t.InitDefaultQueryTables()
	}
}

func (t *Queries) InitDefaultQueryTables() error {
	for _, table := range t.schema.Tables {
		err := t.initDefaultQueryTable(table)
		if err != nil {
			return err
		}
	}
	return nil
}

func (t *Queries) initDefaultQueryTable(table *schema.Table) error {
	placeholder := func(idx int) string {
		if t.schema.DbType == atlas.DbTypePostgre || t.schema.DbType == atlas.DbTypeCockroachDB {
			return fmt.Sprintf("$%d", idx)
		}
		return "?"
	}

	// INSERT
	insertValues := buildInsertValues(table, placeholder)
	t.AddQuery(table.Name, &Query{
		Name:    "insert",
		Comment: "default query - insert",
		Sql:     fmt.Sprintf("INSERT INTO %s VALUES (%s)", table.Name, insertValues),
	})

	// WHERE (PK 기준)
	where := buildWhere(table, placeholder, 1)

	// SELECT
	t.AddQuery(table.Name, &Query{
		Name:    "select",
		Comment: "default query - select",
		Sql:     fmt.Sprintf("SELECT * FROM %s%s", table.Name, where),
	})

	// DELETE
	t.AddQuery(table.Name, &Query{
		Name:    "delete",
		Comment: "default query - delete",
		Sql:     fmt.Sprintf("DELETE FROM %s%s", table.Name, where),
	})

	// UPDATE
	setClause, nextIdx := buildUpdateSet(table, placeholder)
	whereUpdate := buildWhere(table, placeholder, nextIdx)
	t.AddQuery(table.Name, &Query{
		Name:    "update",
		Comment: "default query - update",
		Sql:     fmt.Sprintf("UPDATE %s SET %s%s", table.Name, setClause, whereUpdate),
	})

	return nil
}

func buildInsertValues(table *schema.Table, placeholder func(int) string) string {
	var sb strings.Builder
	for i, col := range table.Columns {
		if table.PrimaryKey != nil && col.Name == table.PrimaryKey.Name {
			sb.WriteString("NULL")
		} else {
			sb.WriteString(placeholder(i + 1))
		}
		if i < len(table.Columns)-1 {
			sb.WriteString(", ")
		}
	}
	return sb.String()
}

func buildUpdateSet(table *schema.Table, placeholder func(int) string) (string, int) {
	var sb strings.Builder
	idx := 1
	for _, col := range table.Columns {
		if table.PrimaryKey != nil && col.Name == table.PrimaryKey.Name {
			continue
		}
		sb.WriteString(fmt.Sprintf("%s = %s, ", col.Name, placeholder(idx)))
		idx++
	}
	query := strings.TrimSuffix(sb.String(), ", ")
	return query, idx
}

func buildWhere(table *schema.Table, placeholder func(int) string, startIdx int) string {
	if table.PrimaryKey == nil || len(table.PrimaryKey.Parts) != 1 {
		return ""
	}
	pk := table.PrimaryKey.Parts[0].C.Name
	if pk == "" {
		return ""
	}
	return fmt.Sprintf(" WHERE %s = %s", pk, placeholder(startIdx))
}

func (t *Queries) AddQuery(tableName string, query *Query) {
	if t.Class == nil {
		t.Class = make(map[string][]*Query, 10)
	}
	t.Class[tableName] = append(t.Class[tableName], query)
}

//------------------------------------------------------------------------------------------------//
// query

type Query struct {
	Name    string `json:"name"`
	Comment string `json:"comment,omitempty"`
	Sql     string `json:"sql"`

	// options
	CustomFieldTypes []*CustomFieldType `json:"custom_field_types,omitempty"`
	InsertMulti      bool               `json:"insert_multi,omitempty"`
	UpdateNullIgnore bool               `json:"update_null_ignore,omitempty"`
	ErrQuery         string             `json:"-"`
	ErrParser        string             `json:"-"`
}

type CustomFieldType struct {
	TableName  string `json:"table_name"`
	FieldName  string `json:"field_name"`
	CustomType string `json:"type"`
}

func (t *Query) AddCustomType(tableName, fieldName, customType string) {
	t.CustomFieldTypes = append(t.CustomFieldTypes, &CustomFieldType{
		TableName:  tableName,
		FieldName:  fieldName,
		CustomType: customType,
	})
}

func (t *Query) GetCustomType(fieldName string) string {
	for _, pt := range t.CustomFieldTypes {
		if pt.FieldName == fieldName {
			return pt.CustomType
		}
	}
	return ""
}
