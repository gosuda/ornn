// Code generated by ornn/codegen; DO NOT EDIT.
// This file was generated and any changes will be lost.

package gen

import (
	"fmt"
	"time"

	. "github.com/gosuda/ornn/db"
)

type Gen struct {
	Org_members   Org_members
	Organizations Organizations
	Projects      Projects
	Tasks         Tasks
	Users         Users
}

func (t *Gen) Init(
	job *Job,
) {
	t.Org_members.Init(job)
	t.Organizations.Init(job)
	t.Projects.Init(job)
	t.Tasks.Init(job)
	t.Users.Init(job)
}

func (t *Org_members) Init(
	job *Job,
) {
	t.job = job
}

type Org_members struct {
	job *Job
}

func (t *Org_members) Insert(
	val_org_id uint64,
	val_user_id uint64,
	val_role any,
	val_created_at time.Time,
) (
	lastInsertId int64,
	err error,
) {
	args := []any{
		val_org_id,
		val_user_id,
		val_role,
		val_created_at,
	}

	sql := fmt.Sprintf(
		"INSERT INTO org_members VALUES (?, ?, ?, ?)",
	)

	exec, err := t.job.Exec(
		sql,
		args...,
	)
	if err != nil {
		return 0, err
	}

	return exec.LastInsertId()
}

type Org_members_select struct {
	Org_id     uint64
	User_id    uint64
	Role       any
	Created_at time.Time
}

func (t *Org_members) Select() (
	selects []*Org_members_select,
	err error,
) {
	args := []any{}

	sql := fmt.Sprintf(
		"SELECT * FROM org_members",
	)
	ret, err := t.job.Query(
		sql,
		args...,
	)
	if err != nil {
		return nil, err
	}
	defer ret.Close()

	selects = make([]*Org_members_select, 0, 100)
	for ret.Next() {
		scan := &Org_members_select{}
		err := ret.Scan(scan)
		if err != nil {
			return nil, err
		}
		selects = append(selects, scan)
	}

	return selects, nil
}

func (t *Org_members) Delete() (
	rowAffected int64,
	err error,
) {
	args := []any{}

	sql := fmt.Sprintf(
		"DELETE FROM org_members",
	)

	exec, err := t.job.Exec(
		sql,
		args...,
	)
	if err != nil {
		return 0, err
	}

	return exec.RowsAffected()
}

func (t *Org_members) Update(
	set_org_id uint64,
	set_user_id uint64,
	set_role any,
	set_created_at time.Time,
) (
	rowAffected int64,
	err error,
) {
	sql := fmt.Sprintf(
		"UPDATE org_members SET org_id = ?, user_id = ?, role = ?, created_at = ?",
	)
	args := []any{
		set_org_id,
		set_user_id,
		set_role,
		set_created_at,
	}

	exec, err := t.job.Exec(
		sql,
		args...,
	)
	if err != nil {
		return 0, err
	}

	return exec.RowsAffected()
}

func (t *Organizations) Init(
	job *Job,
) {
	t.job = job
}

type Organizations struct {
	job *Job
}

func (t *Organizations) Insert(
	val_id uint64,
	val_name string,
	val_owner_id uint64,
	val_created_at time.Time,
) (
	lastInsertId int64,
	err error,
) {
	args := []any{
		val_id,
		val_name,
		val_owner_id,
		val_created_at,
	}

	sql := fmt.Sprintf(
		"INSERT INTO organizations VALUES (?, ?, ?, ?)",
	)

	exec, err := t.job.Exec(
		sql,
		args...,
	)
	if err != nil {
		return 0, err
	}

	return exec.LastInsertId()
}

type Organizations_select struct {
	Id         uint64
	Name       string
	Owner_id   uint64
	Created_at time.Time
}

func (t *Organizations) Select(
	where_id uint64,
) (
	selects []*Organizations_select,
	err error,
) {
	args := []any{
		where_id,
	}

	sql := fmt.Sprintf(
		"SELECT * FROM organizations WHERE id = ?",
	)
	ret, err := t.job.Query(
		sql,
		args...,
	)
	if err != nil {
		return nil, err
	}
	defer ret.Close()

	selects = make([]*Organizations_select, 0, 100)
	for ret.Next() {
		scan := &Organizations_select{}
		err := ret.Scan(scan)
		if err != nil {
			return nil, err
		}
		selects = append(selects, scan)
	}

	return selects, nil
}

func (t *Organizations) Delete(
	where_id uint64,
) (
	rowAffected int64,
	err error,
) {
	args := []any{
		where_id,
	}

	sql := fmt.Sprintf(
		"DELETE FROM organizations WHERE id = ?",
	)

	exec, err := t.job.Exec(
		sql,
		args...,
	)
	if err != nil {
		return 0, err
	}

	return exec.RowsAffected()
}

func (t *Organizations) Update(
	set_id uint64,
	set_name string,
	set_owner_id uint64,
	set_created_at time.Time,
	where_id uint64,
) (
	rowAffected int64,
	err error,
) {
	sql := fmt.Sprintf(
		"UPDATE organizations SET id = ?, name = ?, owner_id = ?, created_at = ? WHERE id = ?",
	)
	args := []any{
		set_id,
		set_name,
		set_owner_id,
		set_created_at,
		where_id,
	}

	exec, err := t.job.Exec(
		sql,
		args...,
	)
	if err != nil {
		return 0, err
	}

	return exec.RowsAffected()
}

func (t *Projects) Init(
	job *Job,
) {
	t.job = job
}

type Projects struct {
	job *Job
}

type Projects_select struct {
	Id         uint64
	Org_id     uint64
	Name       string
	Slug       string
	Status     any
	Created_at time.Time
	Updated_at time.Time
}

func (t *Projects) Select(
	where_id uint64,
) (
	selects []*Projects_select,
	err error,
) {
	args := []any{
		where_id,
	}

	sql := fmt.Sprintf(
		"SELECT * FROM projects WHERE id = ?",
	)
	ret, err := t.job.Query(
		sql,
		args...,
	)
	if err != nil {
		return nil, err
	}
	defer ret.Close()

	selects = make([]*Projects_select, 0, 100)
	for ret.Next() {
		scan := &Projects_select{}
		err := ret.Scan(scan)
		if err != nil {
			return nil, err
		}
		selects = append(selects, scan)
	}

	return selects, nil
}

func (t *Projects) Delete(
	where_id uint64,
) (
	rowAffected int64,
	err error,
) {
	args := []any{
		where_id,
	}

	sql := fmt.Sprintf(
		"DELETE FROM projects WHERE id = ?",
	)

	exec, err := t.job.Exec(
		sql,
		args...,
	)
	if err != nil {
		return 0, err
	}

	return exec.RowsAffected()
}

func (t *Projects) Update(
	set_id uint64,
	set_org_id uint64,
	set_name string,
	set_slug string,
	set_status any,
	set_created_at time.Time,
	set_updated_at time.Time,
	where_id uint64,
) (
	rowAffected int64,
	err error,
) {
	sql := fmt.Sprintf(
		"UPDATE projects SET id = ?, org_id = ?, name = ?, slug = ?, status = ?, created_at = ?, updated_at = ? WHERE id = ?",
	)
	args := []any{
		set_id,
		set_org_id,
		set_name,
		set_slug,
		set_status,
		set_created_at,
		set_updated_at,
		where_id,
	}

	exec, err := t.job.Exec(
		sql,
		args...,
	)
	if err != nil {
		return 0, err
	}

	return exec.RowsAffected()
}

func (t *Projects) Insert(
	val_id uint64,
	val_org_id uint64,
	val_name string,
	val_slug string,
	val_status any,
	val_created_at time.Time,
	val_updated_at time.Time,
) (
	lastInsertId int64,
	err error,
) {
	args := []any{
		val_id,
		val_org_id,
		val_name,
		val_slug,
		val_status,
		val_created_at,
		val_updated_at,
	}

	sql := fmt.Sprintf(
		"INSERT INTO projects VALUES (?, ?, ?, ?, ?, ?, ?)",
	)

	exec, err := t.job.Exec(
		sql,
		args...,
	)
	if err != nil {
		return 0, err
	}

	return exec.LastInsertId()
}

func (t *Tasks) Init(
	job *Job,
) {
	t.job = job
}

type Tasks struct {
	job *Job
}

type Tasks_select struct {
	Id          uint64
	Project_id  uint64
	Assignee_id uint64
	Title       string
	Description string
	Priority    any
	Status      any
	Due_date    time.Time
	Created_at  time.Time
	Updated_at  time.Time
}

func (t *Tasks) Select(
	where_id uint64,
) (
	selects []*Tasks_select,
	err error,
) {
	args := []any{
		where_id,
	}

	sql := fmt.Sprintf(
		"SELECT * FROM tasks WHERE id = ?",
	)
	ret, err := t.job.Query(
		sql,
		args...,
	)
	if err != nil {
		return nil, err
	}
	defer ret.Close()

	selects = make([]*Tasks_select, 0, 100)
	for ret.Next() {
		scan := &Tasks_select{}
		err := ret.Scan(scan)
		if err != nil {
			return nil, err
		}
		selects = append(selects, scan)
	}

	return selects, nil
}

func (t *Tasks) Delete(
	where_id uint64,
) (
	rowAffected int64,
	err error,
) {
	args := []any{
		where_id,
	}

	sql := fmt.Sprintf(
		"DELETE FROM tasks WHERE id = ?",
	)

	exec, err := t.job.Exec(
		sql,
		args...,
	)
	if err != nil {
		return 0, err
	}

	return exec.RowsAffected()
}

func (t *Tasks) Update(
	set_id uint64,
	set_project_id uint64,
	set_assignee_id uint64,
	set_title string,
	set_description string,
	set_priority any,
	set_status any,
	set_due_date time.Time,
	set_created_at time.Time,
	set_updated_at time.Time,
	where_id uint64,
) (
	rowAffected int64,
	err error,
) {
	sql := fmt.Sprintf(
		"UPDATE tasks SET id = ?, project_id = ?, assignee_id = ?, title = ?, description = ?, priority = ?, status = ?, due_date = ?, created_at = ?, updated_at = ? WHERE id = ?",
	)
	args := []any{
		set_id,
		set_project_id,
		set_assignee_id,
		set_title,
		set_description,
		set_priority,
		set_status,
		set_due_date,
		set_created_at,
		set_updated_at,
		where_id,
	}

	exec, err := t.job.Exec(
		sql,
		args...,
	)
	if err != nil {
		return 0, err
	}

	return exec.RowsAffected()
}

func (t *Tasks) Insert(
	val_id uint64,
	val_project_id uint64,
	val_assignee_id uint64,
	val_title string,
	val_description string,
	val_priority any,
	val_status any,
	val_due_date time.Time,
	val_created_at time.Time,
	val_updated_at time.Time,
) (
	lastInsertId int64,
	err error,
) {
	args := []any{
		val_id,
		val_project_id,
		val_assignee_id,
		val_title,
		val_description,
		val_priority,
		val_status,
		val_due_date,
		val_created_at,
		val_updated_at,
	}

	sql := fmt.Sprintf(
		"INSERT INTO tasks VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)",
	)

	exec, err := t.job.Exec(
		sql,
		args...,
	)
	if err != nil {
		return 0, err
	}

	return exec.LastInsertId()
}

func (t *Users) Init(
	job *Job,
) {
	t.job = job
}

type Users struct {
	job *Job
}

func (t *Users) Insert(
	val_id uint64,
	val_email string,
	val_username string,
	val_status any,
	val_created_at time.Time,
	val_updated_at time.Time,
) (
	lastInsertId int64,
	err error,
) {
	args := []any{
		val_id,
		val_email,
		val_username,
		val_status,
		val_created_at,
		val_updated_at,
	}

	sql := fmt.Sprintf(
		"INSERT INTO users VALUES (?, ?, ?, ?, ?, ?)",
	)

	exec, err := t.job.Exec(
		sql,
		args...,
	)
	if err != nil {
		return 0, err
	}

	return exec.LastInsertId()
}

type Users_select struct {
	Id         uint64
	Email      string
	Username   string
	Status     any
	Created_at time.Time
	Updated_at time.Time
}

func (t *Users) Select(
	where_id uint64,
) (
	selects []*Users_select,
	err error,
) {
	args := []any{
		where_id,
	}

	sql := fmt.Sprintf(
		"SELECT * FROM users WHERE id = ?",
	)
	ret, err := t.job.Query(
		sql,
		args...,
	)
	if err != nil {
		return nil, err
	}
	defer ret.Close()

	selects = make([]*Users_select, 0, 100)
	for ret.Next() {
		scan := &Users_select{}
		err := ret.Scan(scan)
		if err != nil {
			return nil, err
		}
		selects = append(selects, scan)
	}

	return selects, nil
}

func (t *Users) Delete(
	where_id uint64,
) (
	rowAffected int64,
	err error,
) {
	args := []any{
		where_id,
	}

	sql := fmt.Sprintf(
		"DELETE FROM users WHERE id = ?",
	)

	exec, err := t.job.Exec(
		sql,
		args...,
	)
	if err != nil {
		return 0, err
	}

	return exec.RowsAffected()
}

func (t *Users) Update(
	set_id uint64,
	set_email string,
	set_username string,
	set_status any,
	set_created_at time.Time,
	set_updated_at time.Time,
	where_id uint64,
) (
	rowAffected int64,
	err error,
) {
	sql := fmt.Sprintf(
		"UPDATE users SET id = ?, email = ?, username = ?, status = ?, created_at = ?, updated_at = ? WHERE id = ?",
	)
	args := []any{
		set_id,
		set_email,
		set_username,
		set_status,
		set_created_at,
		set_updated_at,
		where_id,
	}

	exec, err := t.job.Exec(
		sql,
		args...,
	)
	if err != nil {
		return 0, err
	}

	return exec.RowsAffected()
}
